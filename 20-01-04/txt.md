## computed计算属性
>计算属性计算时所依赖的属性一定是响应式依赖，否则计算属性不会执行

>计算属性是基于依赖进行缓存的，就是说在依赖没有更新的情况，调用计算属性并不会重新计算，可以减少开销

### computed应用场景
>复杂的渲染数据计算，用computed计算属性可以减少一定计算开销，增加可维护性

>从Vuex Store中收集相关信息，对Vuex中的数据做计算的时候的要特别注意computed的缓存属性，在对Vuex中的对象值进行属性修改的时候，并不会触发computed的中值的变化，这时需要Object.assign({},obj)对依赖对象进行跟新返回一个新对象触发依赖跟新

>表单校验，这个应用场景应该是比较常见的，利用正则表达式对每个表单项的实时监控，判断表单是否可以提交
## methods  大多数事件方法调用写在此处
>method的另一种用法:在模板中使用methods

>当模版中的某个循环的值需要进行一定逻辑运算时，这时候你就可以使用methods方法，将对应的值传入，然后计算出结果返回到模版显示，这个时候用computed是没法实现的，computed中你无法传参，methods和computed除了这个不一样之外，还有就是在methods中的计算是不会做缓存的，也就是你调用多少次就会计算多少次，相对computed的开销要大一些。
## watch  监听属性
>侦听属性是专门用来观察和响应vue实例上的数据变动，能使用watch属性的场景基本上都可以使用computed属性，而且computed属性开销小，性能高，因此能使用computed就尽量使用computed属性，那么watch属性是不是就没用武之地了呢？当执行异步操作的时候你可能就必须用watch而不是computed了。
## created
>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
## provide和inject
>定义：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。

>定义说明：这对选项是一起使用的。以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

>通俗的说就是：组件得引入层次过多，我们的子孙组件想要获取祖先组件得资源，那么怎么办呢，总不能一直取父级往上吧，而且这样代码结构容易混乱。这个就是这对选项要干的事情。
```
provide，向下提供信息，这里提供的是当前的vue实例，相当于给了后代一个接口。这样在任何的后代组件中，都可以使用inject选项来接收指定的我们想要添加在这个实例上的属性。

这样也就可以访问了，当做当前vue实例的属性。这样做的好处，相当于给了一个捷径，不用使用$parent一级一级的访问。

我们可以把依赖注入看作一部分"大面积有效的prop"，除了祖先组件不需要知道哪些后代组件来使用它提供的属性、后代组件不需要知道被注入的属性来自哪里
```
## Vue.$parent和Vue.$children
```
1.this.$parent 可以直接访问该组件的父实例或组件；
2.父组件也可以通过this.$children 访问它所有的子组件，
3.$parent和$children 可以递归向上或向下无线访问， 直到根实例或最内层的组件。
4.当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。
```
## 插槽
>课件7、8、9三种插槽方式
>一条规则:父级模板里的所有内容都是在父级作用域中编译的;子模版里的所有内容都是在子作用域中编译的。互不干扰互不引用。

## cli  Vue的脚手架
安装过程需要查看文档
```
npm install global @vue/cli
vue create hw
```




## scoped   常用在Vue中的style标签上
>在vue文件中的style标签上，有一个特殊的属性：scoped。当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有style标签全部加上了scoped，相当于实现了样式的模块化。



多多看看关于布局的骨架和样式，毕竟css不占太多的性能优势